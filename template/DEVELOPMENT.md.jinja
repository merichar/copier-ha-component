# Development Guide for {{ component_name }}

This guide covers developing and testing this Home Assistant custom component.

## Table of Contents

- [Environment Setup](#environment-setup)
- [Project Structure](#project-structure)
- [Adding Platforms and Features](#adding-platforms-and-features)
- [Running Tests](#running-tests)
- [Manual Testing with Home Assistant](#manual-testing-with-home-assistant)
- [Code Quality](#code-quality)
- [Debugging](#debugging)
- [Release Process](#release-process)

## Environment Setup

Choose one of three:

### Option A: Devcontainer in VS Code (Recommended)

Everything installs automatically (HA dev environment, Python 3.12, dependencies, prek).

1. Install [Dev Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)
2. Open this project in VS Code
3. Click "Reopen in Container" when prompted (or use Command Palette: "Dev Containers: Reopen in Container")
4. Wait for the container to build and dependencies to install

The devcontainer provides a consistent development environment with everything pre-configured.

### Option B: Standalone Docker

Use a containerized development environment without VS Code integration.

1. **Start the development container**:
   ```bash
   docker compose -f .devcontainer/docker-compose.yml up -d
   ```

2. **Enter the container**:
   ```bash
   docker compose -f .devcontainer/docker-compose.yml exec devcontainer bash
   ```

3. **Install dependencies** (inside container):
   ```bash
   uv pip install -e .[dev]
   ```

   *Note: pip users can substitute `uv pip` with `pip` in all commands.*

4. **Install prek (pre-commit) hooks** (inside container):
   ```bash
   prek install
   ```

5. **Run tests** (inside container):
   ```bash
   pytest
   ```

6. **Exit container**:
   ```bash
   exit
   ```

7. **Stop container when done**:
   ```bash
   docker compose -f .devcontainer/docker-compose.yml down
   ```

Note: This uses the development container image. For running a full Home Assistant instance to manually test your component, see [Manual Testing with Home Assistant](#manual-testing-with-home-assistant).

### Option C: Manual Setup

Work directly on your host machine without containers.

1. **Install uv**
   ```bash
   # macOS/Linux
   curl -LsSf https://astral.sh/uv/install.sh | sh

   # Windows
   powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
   ```

   *Note: pip users can substitute `uv pip` with `pip` in all commands.*

2. **Create and activate virtual environment**:
   ```bash
   uv venv

   # Activate (choose based on your OS/shell)
   source .venv/bin/activate           # macOS/Linux (bash/zsh)
   source .venv/bin/activate.fish      # macOS/Linux (fish)
   .venv\Scripts\activate              # Windows (cmd)
   .venv\Scripts\Activate.ps1          # Windows (PowerShell)
   ```

3. **Install dependencies**:
   ```bash
   uv pip install -e .[dev]
   ```

4. **Install prek (pre-commit) hooks** (recommended):
   ```bash
   prek install
   ```

## Project Structure

```
{{ repo_name }}/
├── .devcontainer/
│   ├── devcontainer.json        # VS Code devcontainer config
│   └── docker-compose.yml       # Development container setup
├── .editorconfig                # Editor-agnostic formatting rules
├── .gitignore
├── .pre-commit-config.yaml      # prek (pre-commit) hooks configuration
├── custom_components/
│   └── {{ component_slug }}/
│       ├── __init__.py          # Component setup and entry points
│       ├── manifest.json        # Component metadata and requirements
│       ├── const.py             # Constants and configuration
│       ├── diagnostics.py       # Debug data export (always included)
│       ├── system_health.py     # System health info (always included)
{% if "polling" in integration_type %}│       ├── coordinator.py       # Data update coordinator
{% endif %}{% if include_config_flow %}│       ├── config_flow.py       # UI configuration flow
│       ├── strings.json         # Translations for config flow
{% endif %}│       └── [platforms]/        # Add via scripts/scaffold.py
├── scripts/
│   ├── check_version.py         # Version consistency checker
│   ├── scaffold.py              # Add platforms and features
│   ├── SCAFFOLD.md              # Scaffold documentation
│   └── scaffolds/               # Platform templates
│       ├── entity.py.jinja      # Base entity
│       ├── ENTITY_BASE_CLASS.md # Base entity guide
│       ├── api.py.jinja
│       ├── sensor.py.jinja
│       └── ...
├── tests/
│   └── test_init.py             # Unit and integration tests
├── docker-compose.yml           # Run full HA instance for manual testing
├── hacs.json                    # HACS integration metadata
├── pyproject.toml               # Python project configuration
└── README.md                    # User-facing documentation
```

### Core Files (Always Included)

**`manifest.json`**
- Defines your component's metadata for Home Assistant
- Lists required dependencies and minimum Home Assistant version
- Specifies IoT class: `{{ iot_class }}`

**`__init__.py`**
- Entry point for your component
{% if include_config_flow %}- Sets up config entries and forwards to platforms
{% else %}- Sets up component from YAML configuration
{% endif %}- Handles component lifecycle (setup, unload)
{% if "polling" in integration_type %}- Initializes the DataUpdateCoordinator
{% endif %}

**`const.py`**
- Defines constants used throughout the component
- Domain name, logger, default configuration values
- Update intervals, timeouts, and other configurable settings

**`diagnostics.py`**
- Provides debug data export for troubleshooting
- Accessible via Settings -> Devices & Services -> Device -> Download Diagnostics

**`system_health.py`**
- Reports component health in Settings -> System -> System Health
- Shows connection status and last update time

{% if "polling" in integration_type %}**`coordinator.py`**
- DataUpdateCoordinator manages periodic data fetching
- Handles API calls and error recovery
- **TODO**: Implement `_async_update_data()` with your API logic
- Default update interval: 30 seconds (adjust in __init__)
- All entities automatically update when coordinator fetches new data

{% endif %}{% if include_config_flow %}**`config_flow.py`**
- Handles UI-based configuration flow
- Validates user input and creates config entries
- Provides a better user experience than YAML configuration

**`strings.json`**
- Provides translations for the config flow UI
- Currently only English, but can be expanded to other languages
{% endif %}

**`hacs.json`**
- HACS integration metadata
- Makes component discoverable in HACS
- Already configured with your component name

### Scaffolded Files (Add As Needed)

The following files are NOT included by default. Generate them using `python scripts/scaffold.py`:

**`entity.py`** (optional base class)
- Base entity class for all platforms
{% if "polling" in integration_type %}- Extends CoordinatorEntity for automatic updates
{% else %}- Extends Entity for manual state management
{% endif %}- Provides common device_info and unique_id logic
{% if integration_type == "assumed_state" %}- Configured with assumed_state=True for one-way communication
{% endif %}- Recommended for multi-platform integrations

**`api.py`** (communication layer)
- Communication layer for external services/devices
{% if "polling" in integration_type %}- Called by coordinator to fetch data
{% elif "push" in integration_type %}- Handles incoming webhooks or websocket connections
{% elif integration_type == "assumed_state" %}- Sends one-way commands to devices
{% endif %}- Isolates network/device communication from Home Assistant logic

**`services.yaml`** (custom services)
- Defines custom actions beyond standard entity controls
- Examples: refresh data, calibrate device, send custom commands

**Platform files** (entity platforms)
- `sensor.py`, `binary_sensor.py`, `switch.py`, `button.py`, etc.
- Implement specific entity types for your integration
- Auto-detect and use `entity.py` if present

**Device automation** (optional)
- `device_trigger.py`, `device_action.py`, `device_condition.py`
- Enable device automation in the UI

See [Adding Platforms and Features](#adding-platforms-and-features) below for usage.

## Adding Platforms and Features

Use the scaffold script to generate platforms and features:

### List Available Scaffolds

```bash
python scripts/scaffold.py --list
```

### Common Workflow

1. **Start with base entity class** (optional, recommended for multi-platform integrations):
   ```bash
   python scripts/scaffold.py entity
   ```

   Edit `custom_components/{{ component_slug }}/entity.py` to customize device_info and unique_id patterns.

2. **Add API communication** (if your integration needs external communication):
   ```bash
   python scripts/scaffold.py api
   ```

   Edit `custom_components/{{ component_slug }}/api.py` to implement your API client.

3. **Add platforms**:
   ```bash
   python scripts/scaffold.py sensor
   python scripts/scaffold.py switch
   python scripts/scaffold.py binary_sensor
   ```

   Platforms automatically use `entity.py` if present, or CoordinatorEntity if not.

4. **Add custom services** (optional):
   ```bash
   python scripts/scaffold.py services
   ```

   Then register services in `__init__.py`.

### Available Scaffolds

**Base Classes:**
- `entity` - Base entity class for shared device_info

**Communication:**
- `api` - API client for external communication
- `application_credentials` - OAuth2 authorization flow

**Entity Platforms:**
- `sensor` - Read-only data (temperature, battery, status)
- `binary_sensor` - On/off states (motion, door open/closed)
- `switch` - Controllable on/off devices
- `button` - Trigger actions (restart, calibrate)
- `climate` - Thermostats and HVAC control
- `cover` - Garage doors, blinds, shutters
- `fan` - Fans with speed and direction control
- `light` - Lights with brightness/color
- `lock` - Smart locks

**Optional Features:**
- `services` - Custom service definitions

**Device Automation:**
- `device_trigger` - Automation triggers
- `device_action` - Automation actions
- `device_condition` - Automation conditions

See [scripts/SCAFFOLD.md](scripts/SCAFFOLD.md) for complete documentation.

### Example: Adding a Switch Platform

```bash
# Generate the scaffold
python scripts/scaffold.py switch

# Edit the file
# custom_components/{{ component_slug }}/switch.py is now created

# Customize the switch logic
# - Implement is_on property
# - Implement async_turn_on method
# - Implement async_turn_off method
```

{% if include_config_flow %}The platform will be automatically discovered. Just restart Home Assistant.
{% else %}Add to your `configuration.yaml`:
```yaml
switch:
  - platform: {{ component_slug }}
```
{% endif %}

### Regenerating with --force

If you need to regenerate a file (e.g., after adding `entity.py`):

```bash
python scripts/scaffold.py sensor --force
```

This overwrites the existing file. **Make sure to save any custom changes first.**

{% if "polling" in integration_type %}### Working with the Coordinator

Your component uses a DataUpdateCoordinator for efficient data fetching.

**Customize update interval** in `coordinator.py`:
```python
super().__init__(
    hass,
    LOGGER,
    name=DOMAIN,
    update_interval=timedelta(minutes=5),  # Adjust as needed
)
```

**Implement data fetching** in `coordinator.py`:
```python
async def _async_update_data(self):
    """Fetch data from API."""
    try:
        async with async_timeout.timeout(10):
            # TODO: Replace with your API call
            data = await self.api.fetch_data()
        return data
    except Exception as exception:
        raise UpdateFailed(f"Error: {exception}") from exception
```

**Access coordinator data** in entities:
```python
@property
def native_value(self):
    """Return sensor value."""
    return self.coordinator.data.get("temperature")
```

**Manually trigger refresh**:
```python
await self.coordinator.async_request_refresh()
```

{% elif integration_type != "none" %}### Direct Communication (No Coordinator)

Your component communicates directly without a coordinator.

**Implement communication** in `api.py`:
```python
async def send_command(self, command: str) -> bool:
    """Send command to device."""
    # TODO: Implement your communication logic
    pass
```

**Update entity state** manually:
```python
async def async_turn_on(self, **kwargs):
    """Turn on the device."""
    success = await self.api.send_command("power_on")
    if success:
        self._attr_is_on = True
        self.async_write_ha_state()
```

{% endif %}

## Running Tests

Tests use pytest with Home Assistant test fixtures.

### Run all tests:
```bash
pytest
```

### Run specific test file:
```bash
pytest tests/test_init.py
```

### Run with coverage:
```bash
pytest --cov=custom_components.{{ component_slug }} --cov-report=html
```
Then open `htmlcov/index.html` in your browser to see coverage details.

### Run with verbose output:
```bash
pytest -v
```

### Writing Tests

Tests should cover:
- Component setup and teardown
{% if include_config_flow %}- Config flow validation
- Config entry setup/unload
{% endif %}- Entity state and attributes
- Service calls
- Error handling

Example test structure:
```python
async def test_sensor_state(hass: HomeAssistant) -> None:
    """Test sensor reports correct state."""
    # Arrange: Set up component and entities
    # Act: Trigger state update
    # Assert: Verify correct behavior
```

## Manual Testing with Home Assistant

For testing your component in a real Home Assistant instance:

### Using Docker Compose

1. **Start Home Assistant**:
   ```bash
   docker compose up -d
   ```

   This starts a full Home Assistant instance with your component automatically mounted.

2. **View logs**:
   ```bash
   docker compose logs -f homeassistant
   ```

3. **Access Home Assistant**:
   - Open http://localhost:8123
   - Complete initial setup
   - Configure your component

4. **Stop Home Assistant**:
   ```bash
   docker compose down
   ```

### Configuration

{% if include_config_flow %}Add your integration via the UI:
1. Settings -> Devices & Services
2. Add Integration
3. Search for "{{ component_name }}"
{% else %}Add to `config/configuration.yaml` in your test Home Assistant:
```yaml
{{ component_slug }}:
  # Your test configuration
```
{% endif %}

### Live Reloading

For faster development, you can reload your component without restarting Home Assistant:

1. Go to Developer Tools -> YAML
2. Click "Reload" under "YAML Configuration Reloading"
3. Select "{{ component_name }}"

Note: This only works for some changes. Structural changes may require a full restart.

### Debugging in Container

1. **Exec into Home Assistant container**:
   ```bash
   docker compose exec homeassistant bash
   ```

2. **Check logs**:
   ```bash
   tail -f /config/home-assistant.log
   ```

3. **Enable debug logging** in `config/configuration.yaml`:
   ```yaml
   logger:
     default: info
     logs:
       custom_components.{{ component_slug }}: debug
   ```

## Code Quality

### prek (Pre-commit) Hooks

*prek* runs automatically on `git commit` and checks:
- Python code formatting (ruff)
- YAML syntax
- File size and merge conflicts
- Trailing whitespace

**Run manually** on all files:
```bash
prek run --all-files
```

**Update hooks**:
```bash
prek auto-update
```

### Linting and Formatting

**Check code with ruff**:
```bash
ruff check .
```

**Auto-fix issues**:
```bash
ruff check --fix .
```

**Format code**:
```bash
ruff format .
```

### Type Checking

While not configured by default, you can add mypy for type checking:

```bash
uv pip install mypy
mypy custom_components/{{ component_slug }}
```

## Debugging

### Enable Debug Logging

Add to your Home Assistant `configuration.yaml`:

```yaml
logger:
  default: warning
  logs:
    custom_components.{{ component_slug }}: debug
```

Restart Home Assistant to apply changes.

### Common Issues

**Component not loading**
- Check logs: `docker compose logs homeassistant | grep {{ component_slug }}`
- Verify `manifest.json` is valid JSON
- Ensure all required dependencies are in `manifest.json`

**Import errors**
- Check file structure matches manifest.json
- Verify `__init__.py` exists in component directory
- Check for Python syntax errors: `python -m py_compile custom_components/{{ component_slug }}/*.py`

{% if include_config_flow %}**Config flow not appearing**
- Verify `config_flow` is in `manifest.json`
- Check `config_flow.py` has no syntax errors
- Look for errors in `home-assistant.log`
{% endif %}

**Entities not showing up**
- Check platform is listed in PLATFORMS in `__init__.py`
{% if "polling" in integration_type %}- Verify coordinator is fetching data successfully
{% endif %}- Check entity has unique_id set
- Look for errors during platform setup

### Using Python Debugger

Add breakpoints in your code:

```python
import pdb; pdb.set_trace()
```

When running tests, pytest will drop into debugger at breakpoint.

For debugging in Home Assistant container:
1. Attach to container: `docker attach $(docker compose ps -q homeassistant)`
2. Code will pause at breakpoint
3. Use standard pdb commands (n, s, c, p variable_name)

## Release Process

### Versioning

Follow [Semantic Versioning](https://semver.org/):
- MAJOR version for incompatible API changes
- MINOR version for new functionality
- PATCH version for bug fixes

### Creating a Release

1. **Update version** in `manifest.json`:
   ```json
   {
     "version": "X.Y.Z"
   }
   ```

2. **Commit changes**:
   ```bash
   git add manifest.json
   git commit -m "chore: bump version to X.Y.Z"
   ```

3. **Tag release**:
   ```bash
   git tag -a vX.Y.Z -m "Release version X.Y.Z"
   ```

4. **Push to {{ vcs_name }}**:
   ```bash
   git push origin main --tags
   ```

5. **Create release** on {{ vcs_name }}:
   - Go to your repository
   - Create a new release from your tag
   - Add release notes
   - Publish release

### Publishing to HACS

1. **Ensure your repository has**:
   - Version in `manifest.json`
   - `README.md` with installation instructions
   - At least one release with a version tag

2. **Create your first release** (see steps above)

3. **Submit to HACS default repository** (optional):
   - Follow [HACS submission guidelines](https://hacs.xyz/docs/publish/start)
   - Repository must be public
   - Requires at least one release

### Installing Your Component

Users can install the component via HACS or manually. See the [README.md](README.md) for complete installation instructions.

## Resources

### Home Assistant Development

- [Home Assistant Developer Docs](https://developers.home-assistant.io/)
- [Integration Development Checklist](https://developers.home-assistant.io/docs/development_checklist)
- [Entity Documentation](https://developers.home-assistant.io/docs/core/entity)
- [Config Entries](https://developers.home-assistant.io/docs/config_entries_index)

### Tools

- [Ruff Documentation](https://docs.astral.sh/ruff/)
- [pytest Documentation](https://docs.pytest.org/)
- [pytest-homeassistant-custom-component](https://github.com/MatthewFlamm/pytest-homeassistant-custom-component)
- [uv Documentation](https://docs.astral.sh/uv/)
- [prek Documentation](https://prek.j178.dev/)

## Getting Help

- [Home Assistant Community Forum](https://community.home-assistant.io/)
- [Home Assistant Discord](https://discord.gg/home-assistant)
- [Component Repository]({{ vcs_uri_prefix }}{{ git_username }}/{{ repo_name }}/issues) - Report issues or request features
